package ca.on.oicr.gsi.vidarr;

import ca.on.oicr.gsi.vidarr.ActiveOperation.TransactionManager;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonNode;
import java.lang.System.Logger.Level;
import java.time.Duration;
import java.util.Optional;
import java.util.function.BiPredicate;

/**
 * Stateful operation steps modify the values being carried by an {@link OperationAction} and can
 * access and modify the state
 *
 * <p>It's reasonable to consider every step as a function that takes an input value and provides an
 * output value. Unlike a normal function, steps can be asynchronous and write information to
 * Vidarr's database. Stateful steps may need to track additional information and so wrap the
 * original state as necessary to keep track of the correct program flow
 *
 * @param <InputState> the state the operation "gets" from the previous step
 * @param <OriginalState> the state that initiated the chain of steps
 * @param <OutputState> the state the operation "provides" to the next step
 * @param <Input> the parameter type
 * @param <Output> the return type
 */
public abstract sealed class OperationStatefulStep<
        InputState extends Record,
        OutputState extends Record,
        OriginalState extends Record,
        Input,
        Output>
    permits OperationStatefulStepDebugInfo,
        OperationStatefulStepLog,
        OperationStatefulStepMapping,
        OperationStatefulStepPoll,
        OperationStatefulStepRepeatUntilSuccess,
        OperationStatefulStepRequire,
        OperationStatefulStepStatus,
        OperationStatefulStepSubStep {

  /**
   * A state which can be unwrapped into an inner state
   *
   * <p>The states generated by some of these steps implement this interface to make it easy to
   * crack into the "inner" (first) state. It is not typical for states in workflow engines and
   * provisioners to implement this interface.
   */
  public interface InnerState {

    /**
     * Try to find the inner state
     *
     * @param clazz the class corresponding to the inner
     * @return the inner state of the expected type
     * @param <T> the type of the inner state
     */
    <T> T loadInner(Class<T> clazz);
  }
  /**
   * A simple mapping function
   *
   * <p>This is analogous to {@link java.util.function.BiFunction}, but it can throw an exception
   * which will be caught and logged to Vidarr's database.
   *
   * @param <State> the state type
   * @param <Input> the parameter type
   * @param <Output> the return type
   */
  public interface StatefulTransformer<State, Input, Output> {

    /**
     * Call the function with an argument
     *
     * @param state the current state
     * @param input the argument to use
     * @return the transformed value
     * @throws Exception any exceptions will be caught and redirected through Vidarr's logging and
     *     operation framework
     */
    Output transform(State state, Input input) throws Exception;
  }

  /**
   * The state for a {@link #subStep(StatefulTransformer, OperationAction)}
   *
   * @param child the state for the sub-step
   * @param state the state for the main path
   * @param <State> the type of the sub-step state
   * @param <SubState> the type of the main path state
   */
  public record Child<State, SubState>(Optional<SubState> child, State state)
      implements InnerState {

    @Override
    public <T> T loadInner(Class<T> clazz) {
      return state instanceof InnerState
          ? ((InnerState) state).loadInner(clazz)
          : clazz.cast(state);
    }
  }

  public record RepeatCounter<State>(int attempts, State state) implements InnerState {

    @Override
    public <T> T loadInner(Class<T> clazz) {
      return state instanceof InnerState
          ? ((InnerState) state).loadInner(clazz)
          : clazz.cast(state);
    }
  }

  /**
   * Write new debugging information for this value and state
   *
   * @param fetch the transformation to produce debugging information to write to the database.
   *     Vidarr imposes no schema on this data; it is up to the client to interpret it
   * @return a step to perform write this debugging information
   * @param <State> the current state type
   * @param <OriginalState> the original state type
   * @param <Value> the type of the input value
   */
  public static <State extends Record, OriginalState extends Record, Value>
      OperationStatefulStep<State, State, OriginalState, Value, Value> debugInfo(
          StatefulTransformer<State, Value, JsonNode> fetch) {
    return new OperationStatefulStepDebugInfo<>(fetch);
  }

  /**
   * Log information about the current value and state
   *
   * @param level the logging level
   * @param message a transformer to generate the log message
   * @return a step to write this log message
   * @param <State> the current state type
   * @param <OriginalState> the original state type
   * @param <Value> the type of the input value
   */
  public static <State extends Record, OriginalState extends Record, Value>
      OperationStatefulStep<State, State, OriginalState, Value, Value> log(
          Level level, StatefulTransformer<State, Value, String> message) {
    return new OperationStatefulStepLog<>(level, message);
  }

  /**
   * Change the value using a state-aware function
   *
   * @param transformer the function to apply to the input value and state
   * @return a step to call this function
   * @param <State> the current state type
   * @param <OriginalState> the original state type
   * @param <Input> the type of the input
   * @param <Output> the type of the output
   */
  public static <State extends Record, OriginalState extends Record, Input, Output>
      OperationStatefulStep<State, State, OriginalState, Input, Output> mapping(
          StatefulTransformer<State, Input, Output> transformer) {
    return new OperationStatefulStepMapping<>(transformer);
  }

  /**
   * Unwrap a complex state object to access the original inner state
   *
   * @param clazz the type of the inner state
   * @param transformer the function to apply to the inner state
   * @return a new function that performs the unwrapping and then calls the provided function
   * @param <State> the outer (wrapped) state
   * @param <InnerState> the inner (unwrapped) state
   * @param <Input> the type of the input
   * @param <Output> the type of the output
   */
  public static <State extends Record, InnerState extends Record, Input, Output>
      StatefulTransformer<State, Input, Output> onInnerState(
          Class<InnerState> clazz, StatefulTransformer<InnerState, Input, Output> transformer) {
    return (state, input) ->
        transformer.transform(
            state instanceof OperationStatefulStep.InnerState inner
                ? inner.loadInner(clazz)
                : clazz.cast(state),
            input);
  }

  /**
   * Run an operation repeatedly until it completes
   *
   * <p>This is meant for repeated accessing an external service. Note that if any step in the chain
   * fails, the poll will not be reattempted.
   *
   * @param delay the best-effort time to wait between reattempts
   * @return a step that reattempts the previous steps
   * @param <State> the type of the previous state
   * @param <OriginalState> the original state
   */
  public static <State extends Record, OriginalState extends Record>
      OperationStatefulStep<State, State, OriginalState, PollResult, Void> poll(Duration delay) {
    return new OperationStatefulStepPoll<>(delay);
  }

  /**
   * Run an operation repeated until it succeeds
   *
   * <p>Runs an operation multiple time and retries if it fails on any error-producing step.
   *
   * @param delay the best-effort time to wait between reattempts
   * @param maximumAttempts the maximum number of retries before declaring failure
   * @return a step that reattempts the previous steps until success
   * @param <State> the type of the previous state
   * @param <OriginalState> the original state
   * @param <Value> the type of the input and (unchanged) output
   */
  public static <State extends Record, OriginalState extends Record, Value>
      OperationStatefulStep<State, RepeatCounter<State>, OriginalState, Value, Value>
          repeatUntilSuccess(Duration delay, int maximumAttempts) {
    return new OperationStatefulStepRepeatUntilSuccess<>(delay, maximumAttempts);
  }

  /**
   * Abort the operation if a condition is not met
   *
   * @param success the test to determine if the sequence should continue (true) or go into an error
   *     state (false)
   * @param failureMessage the message to display when a failure occurs
   * @return a step to check this condition
   * @param <State> the type of the previous state
   * @param <OriginalState> the original state
   * @param <Value> the type of the input and (unchanged) output
   */
  public static <State extends Record, OriginalState extends Record, Value>
      OperationStatefulStep<State, State, OriginalState, Value, Value> require(
          BiPredicate<State, Value> success, String failureMessage) {
    return new OperationStatefulStepRequire<>(success, failureMessage);
  }
  /**
   * Change the status of this operation based on the current value and state
   *
   * @param fetch a function that examines the current value and state to produce a corresponding
   *     status
   * @return a step that changes the status
   * @param <State> the type of the previous state
   * @param <OriginalState> the original state
   * @param <Value> the type of the input and (unchanged) output
   */
  public static <State extends Record, OriginalState extends Record, Value>
      OperationStatefulStep<State, State, OriginalState, Value, Value> status(
          StatefulTransformer<State, Value, WorkingStatus> fetch) {
    return new OperationStatefulStepStatus<>(fetch);
  }

  /**
   * Performs a single branching path between steps.
   *
   * <p>This step will first allow the previous steps to run. Once successful, it will check-point
   * this information then run a second sequence of steps. If restarted, it will restart at the
   * checkpoint rather than the beginning.
   *
   * @param spawn a function which examines the current state and input to produce a new initial
   *     state for the subtask
   * @param subtask the action to perform in the subtask
   * @return a steps which executes the subtask
   * @param <State> the type of the state of the main steps
   * @param <SubState> the type of the state of the child steps
   * @param <OriginalState> the type of the original state of the main steps
   * @param <OriginalSubState> the type of the original state of the child steps
   * @param <Input> the type of the input information used for creating the child state
   * @param <Output> the type of the output produced by the child task
   */
  public static <
          State extends Record,
          SubState extends Record,
          OriginalState extends Record,
          OriginalSubState extends Record,
          Input,
          Output>
      OperationStatefulStep<State, Child<State, SubState>, OriginalState, Input, Output> subStep(
          StatefulTransformer<State, Input, OriginalSubState> spawn,
          OperationAction<SubState, OriginalSubState, Output> subtask) {
    return new OperationStatefulStepSubStep<>(spawn, subtask);
  }

  /**
   * Constructs enclosing state from new input state
   *
   * @param inputState the input state to wrap
   * @return the enclosed output state.
   */
  abstract OutputState buildState(InputState inputState);

  /**
   * Get the Jackson type for this step's state
   *
   * @param incoming the Jackson type of the inner type
   * @return the enclosing state type
   */
  abstract JavaType jacksonType(JavaType incoming);

  /**
   * Reset the state to allow restarting a failed operation during manual intervention
   *
   * @param state the original state
   * @param input the upstream operation
   * @return the reset state
   * @throws JsonProcessingException allow JSON decoding errors to occur
   */
  abstract OutputState rewind(
      OutputState state, OperationAction<InputState, OriginalState, Input> input)
      throws JsonProcessingException;

  abstract <TX> void run(
      OperationAction<InputState, OriginalState, Input> input,
      OutputState state,
      ActiveOperation<TX> operation,
      TransactionManager<TX> transactionManager,
      OperationControlFlow<OutputState, Output> next);
}
