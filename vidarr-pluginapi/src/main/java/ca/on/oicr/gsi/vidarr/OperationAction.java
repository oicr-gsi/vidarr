package ca.on.oicr.gsi.vidarr;

import ca.on.oicr.gsi.vidarr.ActiveOperation.TransactionManager;
import ca.on.oicr.gsi.vidarr.OperationStatefulStep.StatefulTransformer;
import ca.on.oicr.gsi.vidarr.OperationStep.Transformer;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JavaType;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Map;

/**
 * An operation action defines a process that takes some initial state and executes a sequence of
 * commands to generate an output value. All actions along the way can be logged to a database to
 * allow crash recovery.
 *
 * <p>This class enforces the use of Java's records for state encapsulation in order to encourage
 * all state to be immutable. It cannot guarantee that, but it is the operation assumption of this
 * design. Mutating the state directly is undefined behaviour.
 *
 * @param <State> the state that will be logged to the database; this type is usually unimportant,
 *     but if it changes, the database recovery will not work
 * @param <OriginalState> the initial state object generated by the workflow or provisioner
 * @param <Value> the return value for this action
 */
public abstract sealed class OperationAction<
        State extends Record, OriginalState extends Record, Value>
    permits OperationActionBranch,
        OperationActionConstant,
        OperationActionDoStep,
        OperationActionDoStatefulStep,
        OperationActionLoad,
        OperationActionReload {

  /**
   * A delayed start and serialization object
   *
   * @param <State> the state being captured
   * @param <Value> the output type of this operation
   */
  public interface Launcher<State, Value> {

    /**
     * Start execution
     *
     * @param operation the active operation associated with this action
     * @param transactionManager the transaction manager to allow writing state and running delayed
     *     operations
     * @param next the flow controller to call when the operation is complete (both for success and
     *     failure)
     * @param <TX> the type of the transactions used by the operation
     */
    <TX> void launch(
        ActiveOperation<TX> operation,
        TransactionManager<TX> transactionManager,
        OperationControlFlow<State, Value> next);

    /**
     * Serialize the current state as JSON
     *
     * @return the serialized state
     */
    JsonNode state();
  }

  /**
   * Create the initial value for an operation action from the state
   *
   * @param <State> the state type for the operation
   * @param <Result> the value type produced
   */
  public interface Loader<State, Result> {

    /**
     * Create the initial value from the provided state
     *
     * @param state the state to use
     * @return the value for the next step
     * @throws Exception any exceptions will be caught and redirected through Vidarr's logging and
     *     operation framework
     */
    Result prepare(State state) throws Exception;
  }

  /**
   * The state associated with a branching operation
   *
   * @param name the name of the branch
   * @param inner the state of that branch
   */
  public record BranchState(String name, JsonNode inner) {}

  static final ObjectMapper MAPPER = new ObjectMapper();

  /**
   * Create a new action that can follow many paths
   *
   * <p>This operation has limits to the type safety it can provide; it requires that all paths
   * present during creation of the state are available during subsequent runs.
   *
   * @param branches the possible name operations to use; they must all produce the same output
   * @return a new action that picks the correct path and executes it
   * @param <Output> the output value
   */
  public static <Output> OperationAction<BranchState, BranchState, Output> branch(
      Map<String, OperationAction<?, ?, Output>> branches) {
    return new OperationActionBranch<>(branches);
  }

  /**
   * Create a new action that returns a value based on the state
   *
   * @param stateClass the class object for the state that is used
   * @param loader the function to extract the value from the state
   * @return the new action to return this value
   * @param <State> the type of the state
   * @param <Value> the type to be returned
   */
  public static <State extends Record, Value> OperationAction<State, State, Value> load(
      Class<State> stateClass, Loader<State, Value> loader) {
    return new OperationActionLoad<>(stateClass, loader);
  }

  /**
   * Create a new action that returns a value based on the state
   *
   * @param typeReference a type reference for the state that is used
   * @param loader the function to extract the value from the state
   * @return the new action to return this value
   * @param <State> the type of the state
   * @param <Value> the type to be returned
   */
  public static <State extends Record, Value> OperationAction<State, State, Value> load(
      TypeReference<State> typeReference, Loader<State, Value> loader) {
    return new OperationActionLoad<>(typeReference, loader);
  }

  /**
   * Create a new action that returns a fixed value
   *
   * @param stateClass the class object for the state that is used
   * @param value the value to return
   * @return the new action to return this value
   * @param <State> the type of the state
   * @param <Value> the type to be returned
   */
  public static <State extends Record, Value> OperationAction<State, State, Value> value(
      Class<State> stateClass, Value value) {
    return new OperationActionConstant<>(stateClass, value);
  }

  /**
   * Create a new action that returns a fixed value
   *
   * @param typeReference a type reference for the state that is used
   * @param value the value to return
   * @return the new action to return this value
   * @param <State> the type of the state
   * @param <Value> the type to be returned
   */
  public static <State extends Record, Value> OperationAction<State, State, Value> value(
      TypeReference<State> typeReference, Value value) {
    return new OperationActionConstant<>(typeReference, value);
  }

  abstract State buildState(OriginalState originalState);

  /**
   * Deserialize an initial state for this operation from JSON
   *
   * @param originalState the original state as JSON
   * @return the deserialized original state
   * @throws JsonProcessingException thrown if the JSON does not match the correct structure for the
   *     original state
   */
  public abstract OriginalState deserializeOriginal(JsonNode originalState)
      throws JsonProcessingException;

  /**
   * Create a new branch state by serializing a state object
   *
   * @param name the name of the branch
   * @param originalState the initial state of that branch
   * @return the enclosing branch state
   */
  public BranchState intoBranch(String name, OriginalState originalState) {
    return new BranchState(name, MAPPER.valueToTree(buildState(originalState)));
  }

  abstract JavaType jacksonType();

  /**
   * Begin execution from a new state
   *
   * @param originalState the new state to start with
   * @return a launcher to being execution
   */
  public final Launcher<State, Value> launch(OriginalState originalState) {
    final var state = buildState(originalState);
    final var jsonState = MAPPER.valueToTree(state);
    return new Launcher<>() {
      @Override
      public <TX> void launch(
          ActiveOperation<TX> operation,
          TransactionManager<TX> transactionManager,
          OperationControlFlow<State, Value> next) {
        run(state, operation, transactionManager, next);
      }

      @Override
      public JsonNode state() {
        return jsonState;
      }
    };
  }

  /**
   * Transform the current value into another with state information
   *
   * <p>This is syntactic sugar for {@link OperationStatefulStep#mapping(StatefulTransformer)}
   *
   * @param mapper the transformation step to apply
   * @return a new operation that will apply this transformation
   * @param <Output> the result type of the transformation
   */
  public final <Output> OperationAction<State, OriginalState, Output> map(
      StatefulTransformer<State, Value, Output> mapper) {
    return then(OperationStatefulStep.mapping(mapper));
  }

  /**
   * Transform the current value into another
   *
   * <p>This is syntactic sugar for {@link OperationStep#mapping(Transformer)}
   *
   * @param mapper the transformation step to apply
   * @return a new operation that will apply this transformation
   * @param <Output> the result type of the transformation
   */
  public final <Output> OperationAction<State, OriginalState, Output> map(
      Transformer<Value, Output> mapper) {
    return then(OperationStep.mapping(mapper));
  }

  /**
   * Restart an operation from the database
   *
   * @param state the JSON state previously serialised
   * @return a launcher to being execution
   */
  public final Launcher<State, Value> recover(JsonNode state) {
    final State s = MAPPER.convertValue(state, jacksonType());
    return new Launcher<>() {
      @Override
      public <TX> void launch(
          ActiveOperation<TX> operation,
          TransactionManager<TX> transactionManager,
          OperationControlFlow<State, Value> next) {
        transactionManager.scheduleTask(() -> run(s, operation, transactionManager, next));
      }

      @Override
      public JsonNode state() {
        return MAPPER.valueToTree(s);
      }
    };
  }

  /**
   * Recover and operation from the database and discard and error conditions and allow it to start
   * again.
   *
   * @param state the JSON state previously serialised
   * @return a launcher to being execution
   */
  public final Launcher<State, Value> retry(JsonNode state) {
    try {
      final var s = rewind(MAPPER.convertValue(state, jacksonType()));

      return new Launcher<>() {
        @Override
        public <TX> void launch(
            ActiveOperation<TX> operation,
            TransactionManager<TX> transactionManager,
            OperationControlFlow<State, Value> next) {
          transactionManager.scheduleTask(() -> run(s, operation, transactionManager, next));
        }

        @Override
        public JsonNode state() {
          return MAPPER.valueToTree(s);
        }
      };
    } catch (JsonProcessingException e) {
      return new Launcher<>() {
        final String message = "Failed to rewind state: " + e.getMessage();

        @Override
        public <TX> void launch(
            ActiveOperation<TX> operation,
            TransactionManager<TX> transactionManager,
            OperationControlFlow<State, Value> next) {
          next.error(message);
        }

        @Override
        public JsonNode state() {
          return MAPPER.nullNode();
        }
      };
    }
  }

  abstract State rewind(State state) throws JsonProcessingException;

  /**
   * Discard the current value and load a new one from the state
   *
   * @param loader a function to load the value from the state
   * @return an action that will load this value
   * @param <Output> the type of the returned value from this operation
   */
  public final <Output> OperationAction<State, OriginalState, Output> reload(
      Loader<State, Output> loader) {
    return new OperationActionReload<>(this, loader);
  }

  abstract <TX> void run(
      State state,
      ActiveOperation<TX> operation,
      TransactionManager<TX> transactionManager,
      OperationControlFlow<State, Value> flow);

  /**
   * Transform the current operation in a way that uses state
   *
   * @param flow the flow control to apply; this flow control might modify the state
   * @return an action that applies this modification
   * @param <OutputState> the type of the state with this flow control
   * @param <Output> the value type after the operation
   */
  public final <OutputState extends Record, Output>
      OperationAction<OutputState, OriginalState, Output> then(
          OperationStatefulStep<State, OutputState, OriginalState, Value, Output> flow) {
    return new OperationActionDoStatefulStep<>(this, flow);
  }

  /**
   * Perform an operation on the current value and return a new value
   *
   * <p>Note that these steps are independent of the state and only operate the input value
   *
   * @param step the step to perform; it must take the current value as input
   * @return a new action that will perform the step
   * @param <Output> the type of the returned value from this operation
   */
  public final <Output> OperationAction<State, OriginalState, Output> then(
      OperationStep<Value, Output> step) {
    return new OperationActionDoStep<>(this, step);
  }
}
